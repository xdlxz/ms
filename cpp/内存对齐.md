C++ 中的内存对齐（Memory Alignment）是指在内存中将数据对象放置在符合特定对齐要求的地址上。
这种对齐是为了优化内存访问的效率，特别是在现代硬件中，CPU 访问未对齐的内存可能导致性能下降，
甚至引发硬件异常。

### 为什么需要内存对齐？
	1. 性能优化：现代 CPU 通过内存总线以块（如 4 字节或 8 字节）读取内存。对齐数据可以使 CPU 只需一次操作即可读取完整的数据。如果数据未对齐，CPU 可能需要多次内存访问，这会增加读取时间，降低性能。
	2. 硬件限制：一些硬件平台对未对齐的访问支持较差，可能引发异

### 内存对齐的规则
不同数据类型对齐的基本规则是：

	1. 每种数据类型都有一个对齐要求（通常是该类型的大小），即该类型的对象必须存放在地址能够被其大小整除的内存位置。
	2. 比如，int 类型的大小通常是 4 字节，那么它的对齐要求也是 4 字节，因此它的地址必须是 4 的倍数。
	3. double 类型的大小是 8 字节，那么它的地址通常要求是 8 的倍数。

 ### 内存对齐示例

```
#include <iostream>

struct MyStruct {
    char a;   // 1 byte
    int b;    // 4 bytes
    short c;  // 2 bytes
};

int main() {
    std::cout << sizeof(MyStruct) << std::endl;
    return 0;
}
```

在这个例子中，MyStruct 的内存布局会受到字节对齐的影响：

	1.	char a 占用 1 字节，存放在地址 0 处。
	2.	接下来是 int b，它要求 4 字节对齐，因此 a 后面需要插入 3 个填充字节（padding），以确保 b 的起始地址是 4 的倍数。
	3.	short c 需要 2 字节对齐，因此它可以紧跟在 b 后面，不需要额外的填充字节。

结构体的实际大小会是 12 字节，而不是 7 字节（1 + 4 + 2），因为编译器插入了 3 个填充字节来满足对齐要求。

### 手动优化结构体的内存对齐

为了减少内存浪费，可以通过调整结构体中成员的顺序，按照从大到小排列成员变量，以减少填充字节的数量。
```
struct MyStruct {
    int b;     // 4 bytes
    short c;   // 2 bytes
    char a;    // 1 byte, followed by 1 byte of padding
};
```
现在，MyStruct 的大小变为 8 字节，因为内存对齐得到了优化，减少了填充字节。

***当类中包含其他类对象时，整个类对象本身也需要按照其对齐要求对齐。***


